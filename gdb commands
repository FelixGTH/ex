# Исходник должен быть скомпилирован с флагом -g.
# Статическая линковка библиотек упростит отладку.

# Открытие файла:
gdb файл.exe
gdb --args файл.exe аргументы_программы

# Загрузить core dump, если есть:
gdb файл.exe core

# Переключить фокус между кодом и консолью:
Ctrl+X+A

# Если GDB не видит исходники,
# нужно указать путь к ним вручную:
directory C:/project/финальная_папка


"ГРАФИЧЕСКИЙ ИНТЕРФЕЙС"

# Открыть TUI:
gdb -tui файл.exe
Ctrl+X+A

# Обновить экран TUI:
Ctrl+L

# Листать tui вверх вниз:
Стрелки

"БАЗОВЫЕ КОМАНДЫ"

# Тестовый запуск программы:
run аргументы
r аргументы

# Скрыть cout'ы программы:
r > NUL

# Перенаправление вывода в файл:
r > название_файла


# Выход из отладки:
quit
q

# Остановить выполнение:
Ctrl+C
interrupt

# Показать исходный код (10 строк):
list
l

# Найти строки с "TODO" в текущем файле:
list +/TODO

# Показать код функции:
l функция

# Показать ассемблерный код функции:
disassemble функция 

# Показать регистры процессора:
info registers

# Начинает запись логов в файл gdb.txt:
set logging on

# Заканчивает запись логов:
set logging off

# Показать версию GDB:
show version

# Справка по команде:
help команда

# Показать загруженные DLL:
info sharedlibrary


"ШАГИ ВЫПОЛНЕНИЯ"

# Шаг с обходом (без входа в функции):
next
n
# Шаг на 5 команд вперёд:
n 5

# Шаг с заходом (провалится в функцию, если возможно):
step
s
# Шаг на 5 команд вперёд:
s 5

# Продолжить выполнение до следующей точки останова:
continue
c

# Выйти из текущей функции:
finish

# Принудительный возврат из функции:
return значение

# Продолжить до выхода из функции/цикла:
until

# Продолжить до строки:
until номер_строки

# Остановиться при загрузке DLL:
catch load имя_библиотеки.dll  


"ТОЧКИ ОСТАНОВА"

# Быстрая временная точка останова на текущей строке:
tbreak
tb

# Поставить точку останова на функцию:
break функция
b функция

# Точка на метод класса:
b класс::метод

# Остановка при создании исключения:
catch throw

# Поставить точку останова на строку:
b номер_строки
b файл.cpp:номер_строки

# Остановка по адресу в памяти:
b *0xадрес

# Показать все точки останова:
info break
i b

# Удалить точку останова по индексу:
delete индекс
d индекс

# Удалить все точки:
clear

# Временно отключить точку:
disable индекс

# Включить точку:
enable индекс

# Создать точку с уловием для остановки (например: b main.cpp:20 if x == 5 && y < 0):
b описание_точки if условие

# Добавить условие для точки (например: condition 1 x > 5):
condition индекс условие

# Пропустить N срабатываний точки:
ignore индекс N

# Выполнить команды при срабатывании точки:
commands индекс_точки
# Пример команд:
print x
continue
end

# ПРИМЕРЫ:

# Поставить точки останова на ВСЕ функции класса "Parser":
rbreak Parser::.*

# Точки на все функции в файле "network.cpp":
rbreak network.cpp:.*

# Точки на все функции с "error" в имени:
break .*error.*

# Показать только точки останова с "http" в имени:
info breakpoints -q .*http.*


"WATCHPOINTS"
# (Остановка на конкретной операции.)

# Остановка при записи в переменную:
watch переменная 

# Остановка при чтении переменной:
rwatch переменная

# Остановка при любом доступе:
awatch переменная 

# Список всех watchpoints:
info watchpoints

# Для отслеживания изменений в динамической памяти:
watch *(тип_данных*)0xадрес


"ОПЕРАЦИИ НАД ПЕРЕМЕННЫМИ"

# Вывести структуру/класс в читаемом виде:
set print pretty on

# Вывести значение переменной:
print переменная 
p переменная

# Показывать значение переменной на каждом шаге:
display переменная
d переменная

# Список всех отслеживаемых переменных:
info display

# Перестать отслеживать переменную:
undisplay индекс

# Изменить значение переменной:
set var переменная=значение

# Показать все локальные переменные:
info locals

# Показать все аргументы функции, в которой находишься:
info args

# Показать тип переменной/функции:
whatis переменная
ptype переменная


"СТЕК КОМАНД"

# Показать стек текущей команды:
backtrace
bt

# Стек с локальными переменными:
bt full

# Переключиться на кадр в стеке:
frame номер
f номер

# На кадр выше (ближе к main-функции):
up

# На кадр ниже (дальше от к main-функции):
down

# Информация о текущем кадре:
info frame


"АНАЛИЗ ПАМЯТИ"

# Показать карту памяти процесса,
# если она была сгенерирована:
info proc mappings

# ПРИМЕРЫ:

# Показать 10 слов (4 байта) в hex:
x/10xw &массив

# Показать строку по адресу:
x/s указатель

# Показать целое число:
x/d &число

# 10 байт в hex:
x/10xb &переменная

# 10 символов:
x/10c  &переменная

# 10 инструкций с текущего адреса:
x/10i  $pc

# 5 элементов матрицы начиная с индекса 3:
p *this->data->matrix[3]@5

# Поиск всех указателей на функцию "handler" в памяти:
find /w 0xначальный_адрес 0xконечный_адрес &handler


"МНОГОПОТОЧНОСТЬ"

# Список потоков:
info threads

# Переключиться на поток:
thread номер_потока

# Стек всех потоков:
thread apply all bt


"ПОИСК ПО REGEX"

# Все функции, содержащие regex_последовательность в имени:
info functions regex_последовательность 

# Все глобальные переменные с regex_последовательность в имени:
info variables regex_последовательность 

# Все символы (функции + переменные) с regex_последовательность в имени:
info symbols regex_последовательность

# ПРИМЕРЫ:

# Все функции с "print" в имени:
# Найдёт: print_data, debug_print, _ZNK5Print11isActive
info functions print

# Функции классов Animal и Dog:
# Найдёт: Animal::feed, Dog::bark
info functions (Animal|Dog)::

# Конструкторы/деструкторы MyClass:
# Найдёт: MyClass::MyClass, MyClass::~MyClass
info functions MyClass::

# Функции из пространства имён utils:
# Найдёт: utils::compress, utils::logger::init
info functions utils::.*

# Функции с именами вида create_*_object:
# Найдёт: create_file_object, create_socket_object
info functions create_.*_object

# Шаблонные функции:
# Найдёт: std::vector<int>::push_back, std::vector<std::string>::operator=
info functions std::vector\<.*\>

# Функции-обработчики:
# Найдёт: event_handler, interrupt_handler, _ZN12HttpServer15request_handlerE
info functions .*_handler

# Функции с цифрой в имени:
# Найдёт: step1_init, phase2_processing, crypto_sha256_update
info functions .*[0-9].*

# Перегруженные операторы:
# Найдёт: operator<<, operator=, operator++
info functions operator.*

# Сигнатуры с аргументом FILE*:
# Найдёт: parse_config(FILE*), save_report(FILE*, bool)
info functions .*\(FILE\*\).*